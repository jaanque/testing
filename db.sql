-- SQL script to create the 'messages' table for the Secure Message Sharer

-- Drop the table if it already exists (optional, use with caution in production)
-- Useful for development to ensure a clean setup.
-- Consider commenting this out if you want to preserve existing data.
DROP TABLE IF EXISTS public.messages;

-- Create the 'messages' table
CREATE TABLE public.messages (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    message_text text NULL, -- Or NOT NULL if you want to enforce messages always have text
    access_code text NULL, -- Or NOT NULL

    CONSTRAINT messages_pkey PRIMARY KEY (id),
    CONSTRAINT messages_access_code_key UNIQUE (access_code)
);

-- Add comments to the table and columns for clarity (optional)
COMMENT ON TABLE public.messages IS 'Stores secret messages and their access codes.';
COMMENT ON COLUMN public.messages.id IS 'Unique identifier for each message.';
COMMENT ON COLUMN public.messages.created_at IS 'Timestamp of when the message was created.';
COMMENT ON COLUMN public.messages.message_text IS 'The content of the secret message.';
COMMENT ON COLUMN public.messages.access_code IS 'The 9-digit code to access the message; must be unique.';

-- Enable Row Level Security (RLS) on the table (Recommended for Supabase)
-- This is a good practice, though the actual policies depend on your security requirements.
-- For this application, basic policies would allow:
-- - Anyone to insert (anon role).
-- - Anyone to select based on access_code (anon role).
-- - Anyone to delete based on access_code or id (anon role, specifically handled by the app logic).
-- More restrictive policies could be defined if needed.

ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Example RLS Policies (adjust as needed for your security model):

-- Allow public insert
CREATE POLICY "Allow public insert"
ON public.messages
FOR INSERT
WITH CHECK (true);

-- Allow public select for users who know the access code
CREATE POLICY "Allow public select based on access_code"
ON public.messages
FOR SELECT
USING (true); -- The application logic filters by access_code, RLS can be simpler here
               -- or more complex: USING (auth.anon_key() IS NOT NULL AND messages.access_code = current_setting('request.jwt.claims', true)::json->>'user_access_code')
               -- if you were to pass the code via JWT claims or similar. For this app, JS handles the code matching.

-- Allow public delete for users who know the access code (or for the app to delete by ID after fetch)
CREATE POLICY "Allow public delete based on access_code or id"
ON public.messages
FOR DELETE
USING (true); -- Similar to select, the app logic ensures the correct message is targeted.

-- Note: The RLS policies above are quite permissive and rely on the app's logic
-- to correctly handle access and deletion. For stricter security, especially if other
-- applications or users might access the database directly, you would refine these policies.
-- For example, delete could be restricted to a service role or based on user authentication
-- if messages were tied to specific users.

-- Grant usage on schema public to anon and authenticated roles (usually default in Supabase)
GRANT USAGE ON SCHEMA public TO anon;
GRANT USAGE ON SCHEMA public TO authenticated;

-- Grant all permissions on the table to anon and authenticated roles for this simple app
-- You might want to restrict this further in a production environment (e.g., only SELECT, INSERT, DELETE)
GRANT ALL ON TABLE public.messages TO anon;
GRANT ALL ON TABLE public.messages TO authenticated;

-- If you have specific roles, grant permissions accordingly.
-- Supabase's default roles are `anon` (unauthenticated users) and `authenticated` (logged-in users).
-- For this app, `anon` is sufficient as there's no user login system.

SELECT 'Database schema "messages" created successfully with basic RLS policies.';
